---
# /*
# |    Protect your secrets, protect your sensitive data.
# :    Explore VMware Secrets Manager docs at https://vsecm.com/
# </
# <>/  keep your secrets‚Ä¶ secret
# >/
# <>/' Copyright 2023‚Äìpresent VMware, Inc.
# >/'  SPDX-License-Identifier: BSD-2-Clause
# */

title: VSecM Developer SDK
layout: post
next_url: /docs/use-case-init-container/
prev_url: /docs/use-cases-sidecar/
permalink: /docs/use-case-sdk/
---

## Using **VMware Secrets Manager SDK**

Now, let‚Äôs programmatically consume the **VMware Secrets Manager Secrets** API from our
workload. That way, you will have more control over how you consume and cache
your secrets, and you will not need to add a sidecar to your pod.

## Cleanup

Let‚Äôs remove the workload first:

```bash 
{% raw %}kubectl delete deployment example{% endraw %}
```

That will get rid of the workload; but, assuming you have completed the tutorial
before this one, you‚Äôll still have a secret registered. Let‚Äôs see it:

```bash
{% raw %}# Find the sentinel pod‚Äôs name:
kubectl get po -n vsecm-system

# List secrets:
kubectl exec vsecm-sentinel-778b7fdc78-86v6d -n \
  vsecm-system -- safe -l

{"secrets":[{"name":"example",
"created":"Sat May 13 20:42:20 +0000 2023",
"updated":"Sat May 13 20:42:20 +0000 2023"}]}{% endraw %}
```

Let‚Äôs delete it first:

```bash 
kubectl exec vsecm-sentinel-778b7fdc78-86v6d -n \
  vsecm-system -- safe -w example -d

OK
```

And make sure that it is gone:

```bash
{% raw %}kubectl exec vsecm-sentinel-778b7fdc78-86v6d -n \
  vsecm-system -- safe -l

{"secrets":[]}{% endraw %}
```

All right, our cluster is as clean as a baby‚Äôs butt; let‚Äôs move on.

## Read the Source

Make sure [you examine the manifests][workload-yaml] to gain an understanding
of what kinds of entities you‚Äôve deployed to your cluster.

[workload-yaml]: https://github.com/vmware-tanzu/secrets-manager/tree/main/examples/using-sdk/k8s

## The Benefit of Using **VMware Secrets Manager SDK**

**VMware Secrets Manager SDK** gives direct control of **VMware Secrets Manager Safe** to your workload.

The advantage of this approach is: you are in charge.
The downside of it is: Well, you are in charge üôÇ.

But, jokes aside, your application will have to be
more tightly bound to **VMware Secrets Manager** without a sidecar.

However, when you use a sidecar, your application does not have any idea of
**VMware Secrets Manager**‚Äôs existence. From its perspective, it is merely reading from a file
that something magically updates every once in a while. This
‚Äú*separation of concerns*‚Äù can make your application architecture more
adaptable to changes.

As in anything, there is no one true way to do it. Your approach will depend
on your project‚Äôs requirements.

## Deploying the Demo Workload

That part taken care of; let‚Äôs deploy a workload that uses **VMware Secrets Manager SDK**
instead of *VMware Secrets Manager Sidecar*.

```bash 
# Switch to the VMware Secrets Manager repo:
cd $WORKSPACE/secrets-manager
# Install the workload:
make example-sdk-deploy
# If you are building from the source, 
# use `make example-sdk-deploy-local` instead.
```

And that‚Äôs it. You have your demo workload up and running.

## The Demo App

[Here is the source code of the demo container‚Äôs app][workload-src] for the
sake of completeness.

[workload-src]: https://github.com/vmware-tanzu/secrets-manager/blob/main/examples/using-sdk/main.go

When you check the source code, you‚Äôll see that our demo app tries to get the
secret by querying the SDK via `sentry.Fetch()`, displays the secret if it finds
and repeats this every 5 seconds in an infinite loop.

```go 
for {
	log.Println("fetch")
	d, err := sentry.Fetch()

	// ‚Ä¶ (error handling) truncated ‚Ä¶

	fmt.Printf(
		"secret: updated: %s, created: %s, value: %s\n",
		d.Updated, d.Created, d.Data,
	)

	time.Sleep(5 * time.Second)
}
```

## Verifying the Deployment

If you have been following along so far, when you execute `kubectl get po` will
give you something like this:

```bash 
{% raw %}kubectl get po

NAME                                  READY   STATUS    RESTARTS   AGE
example-85bdbc4cf4-6n2ng  1/1     Running   0          9s{% endraw %}
```

Let‚Äôs check the logs of our pod:

```bash 
{% raw %}kubectl logs example-85bdbc4cf4-6n2ng -f

2023/07/31 20:17:13 fetch
Failed to read the secrets file. Will retry in 5 seconds‚Ä¶
Secret does not exist
2023/07/31 20:17:19 fetch
Failed to read the secrets file. Will retry in 5 seconds‚Ä¶
Secret does not exist

‚Ä¶{% endraw %}
```

We don‚Äôt have any secrets registered to our workload as expected. So, let‚Äôs
add some.

## Registering a Secret

Let‚Äôs register a secret and see how the logs change:

```bash 
{% raw %}# Find the name of the VMware Secrets Manager Sentinel pod:
kubectl get po -n vsecm-system

# register a secret to our workload using VMware Secrets Manager Sentinel:
kubectl exec vsecm-sentinel-778b7fdc78-86v6d -n vsecm-system \
  -- safe \
  -w "example" \
  -s "VSecMRocks!"
  
# Response: 
# OK{% endraw %}
```

Now let‚Äôs check the logs again:

```bash 
{% raw %}kubectl logs example-85bdbc4cf4-6n2ng -f

2023/07/31 20:21:06 fetch
secret: updated: "2023-07-31T20:21:03Z", created: "2023-07-31T20:21:03Z", value: VSecMRocks!

‚Ä¶{% endraw %}
```

[demo-sidecar]: /docs/use-case-sidecar

## Conclusion

So, yay üéâ.  We got our secret; and since we use **VMware Secrets Manager SDK**, we also were able
to get additional metadata such as the creation and modification timestamps of
our secret, which was not possible to retrieve if we used the
[**VMware Secrets Manager Sidecar**][demo-sidecar] approach that we have seen in the
[former tutorial][demo-sidecar].

Next up, you‚Äôll learn about **VMware Secrets Manager Init Container**.
